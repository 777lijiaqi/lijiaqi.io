<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VS Code环境配置 | 知识文档</title>
    <!-- 引入网站图标 -->
    <link rel="icon" type="image/svg+xml" href="../../static/images/favicon.svg">
    <!-- 引入字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;600&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- 引入图标 -->
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 代码高亮 (Prism Tomorrow Night) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <!-- 引入全局样式 -->
    <link rel="stylesheet" href="../../static/css/style.css">

    <style>
        /* --- 本地覆盖样式 (文章专用) --- */
        body {
            padding-top: 80px; /* 给固定导航栏留位置 */
        }

        /* 头部样式复用 */
        .article-header {
            background: rgba(11, 17, 32, 0.95);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 5%;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .back-btn {
            text-decoration: none;
            color: var(--primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: 0.3s;
        }

        .back-btn:hover {
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
        }

        /* 布局容器 */
        .layout {
            display: flex;
            max-width: 1400px;
            margin: 40px auto;
            padding: 0 20px;
            gap: 40px;
        }

        /* 文章内容区域 */
        article {
            flex: 1;
            background: rgba(30, 41, 59, 0.6);
            padding: 40px;
            border-radius: 12px;
            border: 1px solid var(--border);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            max-width: 900px;
        }

        /* 侧边目录栏 */
        aside {
            flex: 0 0 250px;
            position: sticky;
            top: 100px;
            height: fit-content;
            display: none;
        }

        @media (min-width: 1100px) {
            aside { display: block; }
        }

        /* --- Markdown 内容排版 --- */
        h1 {
            text-align: center;
            font-size: 2.2rem;
            margin-bottom: 2rem;
            color: #fff;
            border-bottom: 1px solid var(--border);
            padding-bottom: 1rem;
            font-family: 'Orbitron', sans-serif;
            line-height: 1.4;
        }

        h2 {
            font-size: 1.6rem;
            margin-top: 3rem;
            margin-bottom: 1rem;
            color: var(--primary);
            border-left: 5px solid var(--primary);
            padding-left: 15px;
            font-family: 'Orbitron', sans-serif;
        }

        h3 {
            font-size: 1.3rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
            color: #fff;
            font-family: 'Fira Code', monospace;
        }
        
        h4 {
            font-size: 1.1rem;
            margin-top: 1.5rem;
            color: var(--accent);
            font-family: 'Fira Code', monospace;
        }

        p, li {
            color: var(--text-main);
            margin-bottom: 1rem;
            font-family: 'Segoe UI', sans-serif;
            line-height: 1.8;
        }
        
        /* 列表缩进优化 */
        ul, ol {
            padding-left: 2rem;
            margin-bottom: 1rem;
        }

        /* 代码块样式 */
        code {
            font-family: 'Fira Code', monospace;
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent);
            padding: 2px 6px;
            border-radius: 4px;
        }

        pre {
            background: #0d1117 !important;
            border: 1px solid var(--border);
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        blockquote {
            border-left: 4px solid var(--accent);
            background: rgba(16, 185, 129, 0.05);
            padding: 1rem;
            margin: 1.5rem 0;
            color: #d1d5db;
        }
        
        blockquote p {
            margin: 0;
        }
        
        /* 作者栏特殊样式 */
        .author-quote p {
            text-align: right;
            font-style: italic;
        }

        hr {
            border: 0;
            border-top: 1px solid var(--border);
            margin: 3rem 0;
        }

        /* 目录样式 */
        .toc-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
            padding-bottom: 5px;
        }
        .toc-list { list-style: none; padding-left: 0; }
        .toc-list li { margin-bottom: 10px; }
        .toc-list a {
            color: var(--text-muted);
            font-size: 0.9rem;
            transition: 0.2s;
            display: block;
            border-left: 2px solid transparent;
            padding-left: 10px;
            text-decoration: none;
        }
        .toc-list a:hover, .toc-list a.active {
            color: var(--accent);
            border-left-color: var(--accent);
        }
        
        /* 强调文本 */
        strong {
            color: var(--primary);
        }
    </style>
</head>
<body>

    <!-- 动态背景容器 -->
    <div class="circuit-bg">
        <div class="line v-line" style="--delay: 0s; --left: 10%;"></div>
        <div class="line v-line" style="--delay: 5s; --left: 90%;"></div>
        <div class="line h-line" style="--delay: 2s; --top: 20%;"></div>
        <div class="line h-line" style="--delay: 7s; --top: 80%;"></div>
    </div>

    <!-- 顶部导航 -->
    <header class="article-header">
        <!-- 返回按钮：ID 用于 JS 动态修改链接 -->
        <a id="back-btn" href="../../archive/archive.html?cat=all" class="back-btn">
            <i class="fas fa-chevron-left"></i> <span>Back to Archive</span>
        </a>
        <div style="font-family: 'Fira Code'; color: var(--text-muted); font-size: 0.9rem;">
            system.read(mode=doc_c)
        </div>
    </header>

    <div class="layout">
        <!-- 侧边目录 (TOC) -->
        <aside>
            <div class="toc-title">DIRECTORY</div>
            <ul class="toc-list">
                <li><a href="#sec-1">一、环境准备</a></li>
                <li><a href="#sec-2">二、VS Code 基础配置</a></li>
                <li><a href="#sec-3">三、JSON 编写通用规则</a></li>
                <li><a href="#sec-4">四、核心 JSON 详解</a></li>
                <li><a href="#sec-5">五、协作逻辑总结</a></li>
                <li><a href="#sec-6">六、高级工作区定制</a></li>
                <li><a href="#sec-7">七、如何调试代码</a></li>
                <li><a href="#sec-8">八、如何打包发布</a></li>
            </ul>
        </aside>

        <!-- 文章内容 -->
        <article>
            <h1>VS Code C/C++ 开发环境搭建与深度配置全书</h1>
            
            <p>这是一份经过深度整合的 VS Code C/C++ 开发环境搭建与配置全解教程。本教程将<strong>操作步骤</strong>与<strong>底层原理/JSON详解</strong>完全合并，旨在让你不仅知道“怎么做”，还能理解“为什么”。</p>
            
            <hr>
            
            <p>Visual Studio Code (VS Code) 本质上是一个<strong>强大的文本编辑器</strong>，而不是像 Visual Studio 那样的集成开发环境 (IDE)。它不自带编译器，而是通过<strong>配置文件 (.json)</strong> 调用外部的<strong>编译器</strong>（Compiler）和<strong>调试器</strong>（Debugger）来工作。</p>
            
            <p>本教程将涵盖：</p>
            <ol>
                <li>编译器安装（Windows/Mac/Linux）</li>
                <li>VS Code 基础插件配置</li>
                <li><strong>核心 JSON 文件的编写规则与深度解析</strong>（重点）</li>
                <li>工作区定制（屏蔽干扰文件）</li>
                <li>调试操作指南</li>
                <li>软件打包与发布</li>
            </ol>

            <hr>

            <h2 id="sec-1">一、环境准备（编译器安装）</h2>
            <p>在配置 VS Code 之前，必须确保你的系统里已经有了 C/C++ 编译器。</p>
            
            <h3>1. Windows 用户 (推荐 MinGW-w64)</h3>
            <p>Windows 本身不带 C++ 编译器。</p>
            <ol>
                <li>下载 <strong>MinGW-w64</strong> (建议使用 <a href="https://www.msys2.org/" target="_blank">MSYS2</a> 或 <a href="https://github.com/skeeto/w64devkit/releases" target="_blank">w64devkit</a>)。</li>
                <li>解压到一个路径，例如 <code>C:\mingw64</code>。</li>
                <li><strong>关键步骤</strong>：配置环境变量。
                    <ul>
                        <li>在 Windows 搜索栏搜“编辑系统环境变量”。</li>
                        <li>点击“环境变量” -> “系统变量” -> 找到 <code>Path</code> -> 点击“编辑”。</li>
                        <li>新建一项，填入编译器的 <code>bin</code> 目录路径（例如 <code>C:\mingw64\bin</code>）。</li>
                    </ul>
                </li>
                <li>验证：打开 CMD，输入 <code>g++ --version</code>，显示版本号即成功。</li>
            </ol>

            <h3>2. macOS 用户</h3>
            <p>打开终端，输入 <code>clang --version</code>。如果没有安装，系统会提示你安装 Xcode Command Line Tools，输入 <code>xcode-select --install</code> 即可。</p>

            <h3>3. Linux (Ubuntu/Debian)</h3>
            <p>打开终端安装 GCC 套件：</p>
            <pre><code class="language-bash">sudo apt update
sudo apt install build-essential gdb</code></pre>

            <hr>

            <h2 id="sec-2">二、VS Code 基础配置</h2>
            <ol>
                <li>打开 VS Code。</li>
                <li>点击左侧扩展图标 (Extensions)，搜索并安装 <strong>C/C++</strong> (Microsoft 出品)。</li>
                <li>(可选推荐) 安装 <strong>CMake Tools</strong>，如果你打算做大型项目，这是必备的。</li>
            </ol>

            <hr>

            <h2 id="sec-3">三、JSON 配置文件编写通用规则 (必读)</h2>
            <p>VS Code 的核心配置都在 <code>.json</code> 文件中。在修改之前，必须了解基本规则，否则少一个逗号都会导致无法编译。</p>
            <ol>
                <li><strong>层级结构</strong>：
                    <ul>
                        <li><code>{ ... }</code> 大括号包裹的是<strong>对象 (Object)</strong>。</li>
                        <li><code>[ ... ]</code> 中括号包裹的是<strong>数组 (Array/List)</strong>，里面可以放多个配置项。</li>
                    </ul>
                </li>
                <li><strong>键值对</strong>：
                    <ul>
                        <li>格式为 <code>"Key": Value</code>。</li>
                        <li><strong>注意</strong>：Key (键) 必须用<strong>双引号</strong>包裹。</li>
                    </ul>
                </li>
                <li><strong>分隔符</strong>：
                    <ul>
                        <li>每一行配置结束，如果后面还有内容，<strong>必须加逗号 <code>,</code></strong>。</li>
                        <li><strong>最后一行配置绝对不能加逗号</strong>（这是新手最容易犯的错误）。</li>
                    </ul>
                </li>
                <li><strong>路径写法 (Windows 特有)</strong>：
                    <ul>
                        <li>在 Windows 中路径通常是 <code>C:\Program Files</code>。但在 JSON 字符串中，反斜杠 <code>\</code> 是转义字符。</li>
                        <li>所以必须写成双反斜杠 <code>\\</code> (例如 <code>C:\\MinGW\\bin</code>) 或者使用正斜杠 <code>/</code> (例如 <code>C:/MinGW/bin</code>)。</li>
                    </ul>
                </li>
                <li><strong>VS Code 预定义变量</strong>（避免写死绝对路径）：
                    <ul>
                        <li><code>${workspaceFolder}</code>: 当前打开的文件夹根目录。</li>
                        <li><code>${file}</code>: 当前正在编辑的那个文件。</li>
                        <li><code>${fileDirname}</code>: 当前文件所在的文件夹路径。</li>
                        <li><code>${fileBasenameNoExtension}</code>: 当前文件名，不带后缀 (例如 <code>main</code>)。</li>
                    </ul>
                </li>
            </ol>

            <hr>

            <h2 id="sec-4">四、核心 JSON 文件详解与配置</h2>
            <p>VS Code 的 C/C++ 开发主要依赖 <code>.vscode</code> 文件夹下的三个核心文件。我们将逐一“解剖”。</p>

            <h3>1. <code>c_cpp_properties.json</code> (智能提示配置)</h3>
            <p><strong>作用</strong>：这个文件<strong>只管代码提示</strong>（红色波浪线报错、自动补全、跳转定义）。<strong>它不负责编译！</strong> 哪怕这里写错了，只要代码本身没问题，依然可以通过命令行编译成功。它的作用是让编辑器“看懂”你的代码。</p>
            <p><strong>生成方式</strong>：<code>Ctrl+Shift+P</code> -> 输入 <code>C/C++: Edit Configurations (UI)</code> 或 <code>(JSON)</code>。</p>
            <p><strong>详细解析与配置</strong>：</p>
            <pre><code class="language-json">{
    "configurations": [
        {
            // 1. 配置名称：Win32 或 Linux，在右下角可以选择
            "name": "Win32",

            // 2. 包含路径 (Include Path) —— 最关键！
            // 告诉 VSCode：当你遇到 #include <xxx.h> 时，去哪里找这些文件？
            "includePath": [
                "${workspaceFolder}/**",      // ** 表示递归搜索当前项目下所有子目录
                "C:/mingwo64/include",        // 第三方库的头文件路径要加在这里
                "C:/opencv/build/include"     // 例子：如果你用了 OpenCV
            ],

            // 3. 宏定义 (Defines)
            // 相当于在代码里写了 #define _DEBUG
            // 有些库在不同环境下需要不同的宏才能正常显示代码高亮
            "defines": [
                "_DEBUG",
                "UNICODE",
                "_UNICODE"
            ],

            // 4. 编译器路径
            // VSCode 会根据这个路径去自动探测系统标准头文件（如 stdio.h, iostream）在哪里
            // 如果你这里空着，#include <stdio.h> 就会报错说找不到
            "compilerPath": "C:\\mingw64\\bin\\g++.exe",

            // 5. C/C++ 标准
            // 决定了编辑器按什么语法检查代码。比如你用了 C++20 的新特性，
            // 但这里设为 c++14，编辑器就会画红线报错，虽然编译可能通过。
            "cStandard": "c17",
            "cppStandard": "c++17",

            // 6. 智能提示模式
            // 帮助 VSCode 更好地理解特定编译器的行为（MSVC 和 GCC 处理宏的方式不同）
            // Windows 下用 MinGW 选 windows-gcc-x64
            "intelliSenseMode": "windows-gcc-x64"
        }
    ],
    "version": 4
}</code></pre>

            <h3>2. <code>tasks.json</code> (构建/编译指令)</h3>
            <p><strong>作用</strong>：VS Code 自己不会编译，它通过这个文件<strong>指挥命令行</strong>去干活。这就好比你手动打开 CMD 输入 <code>g++ main.cpp -o main.exe</code>，但这个文件帮你自动完成了。</p>
            <p><strong>生成方式</strong>：菜单栏 <code>Terminal</code> -> <code>Configure Default Build Task</code> -> 选择 <code>g++.exe build active file</code>。</p>
            <p><strong>详细解析与配置</strong>：</p>
            <pre><code class="language-json">{
    "version": "2.0.0",
    "tasks": [
        {
            // 1. 任务类型：cppbuild 是 VSCode 内置专门处理 C++ 的类型
            "type": "cppbuild",

            // 2. 标签 (Label)：这是任务的名字
            // 【重要】launch.json 会通过这个名字来调用这个任务。
            "label": "C/C++: g++.exe 生成活动文件",

            // 3. 命令 (Command)：实际上运行的程序
            "command": "C:\\mingw64\\bin\\g++.exe",

            // 4. 参数 (Args)：传递给 g++ 的参数
            // 整个 args 连起来就是：g++ -fdiagnostics-color=always -g main.cpp -o main.exe
            "args": [
                "-fdiagnostics-color=always", // 让输出的错误信息带颜色
                "-g",                         // 【重要】生成调试信息。没有它无法断点调试！
                "${file}",                    // 当前打开的源文件 (main.cpp)
                "-o",                         // 输出为...
                // 下面这行意思是：在当前目录下生成同名的 .exe (Windows)
                // Linux/Mac 下通常不需要 .exe 后缀
                "${fileDirname}\\${fileBasenameNoExtension}.exe" 
                
                // 如果你要链接库，需在这里继续添加，例如：
                // "-lws2_32" 
            ],

            // 5. 选项 (Options)
            "options": {
                "cwd": "${fileDirname}" // Current Working Directory，设置编译器运行时的当前目录
            },

            // 6. 问题匹配器 (Problem Matcher)
            // 用于捕捉编译器输出的错误信息，并显示在 VSCode 的“问题”面板里
            "problemMatcher": [
                "$gcc"
            ],

            // 7. 分组 (Group)
            // 设为 default: true 后，按 Ctrl+Shift+B 就会直接运行这个任务
            "group": {
                "kind": "build",
                "isDefault": true
            },
            
            "detail": "调试器生成的任务。"
        }
    ]
}</code></pre>

            <h3>3. <code>launch.json</code> (调试配置)</h3>
            <p><strong>作用</strong>：配置调试器（GDB/LLDB），告诉它去哪里找刚才编译好的 <code>.exe</code> 文件，以及如何启动它。</p>
            <p><strong>逻辑链条</strong>：当你按 <code>F5</code> 时 -> VS Code 读取 <code>launch.json</code> -> 发现 <code>preLaunchTask</code> -> 先去跑 <code>tasks.json</code> 编译出 exe -> 编译成功 -> 启动 GDB 挂载该 exe。</p>
            <p><strong>生成方式</strong>：侧边栏“运行和调试”图标 -> <code>create a launch.json file</code> -> 选择 <code>C++ (GDB/LLDB)</code>。</p>
            <p><strong>详细解析与配置</strong>：</p>
            <pre><code class="language-json">{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "g++.exe - 生成和调试活动文件",
            "type": "cppdbg",        // C++ Debug 类型
            "request": "launch",     // 模式：启动 (Launch) 或 附加 (Attach)

            // 1. 程序路径 (Program) —— 最容易错的地方！
            // 这里必须指向 tasks.json 中生成的那个 .exe 文件的绝对路径。
            // 如果 tasks.json 输出了 bin/main.exe，这里也要写 bin/main.exe
            "program": "${fileDirname}\\${fileBasenameNoExtension}.exe",

            // 2. 运行参数 (Args)
            // 如果你的 main 函数需要接收参数 (int argc, char* argv[])
            // 比如 ./main.exe -input data.txt，则写: ["-input", "data.txt"]
            "args": [],

            "stopAtEntry": false,    // true: 启动后自动暂停在 main 函数第一行
            "cwd": "${fileDirname}", // 调试时的“当前工作目录”，读写相对路径文件时以此为准
            "environment": [],       // 环境变量设置
            
            // 3. 控制台类型
            // externalConsole: true  -> 弹出一个独立的黑色 cmd 窗口 (推荐新手使用，方便看输出)
            // externalConsole: false -> 输出显示在 VSCode 下方的“调试控制台”里
            "externalConsole": false,

            "MIMode": "gdb",
            
            // 4. 调试器路径
            // 必须指向 gdb.exe 的完整路径
            "miDebuggerPath": "C:\\mingw64\\bin\\gdb.exe",

            "setupCommands": [
                {
                    "description": "为 gdb 启用整齐打印",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],

            // 5. 预启动任务 (PreLaunchTask) —— 关键中的关键！
            // 这个字符串必须和 tasks.json 里的 "label" 完全一致 (连空格都不能差)。
            // 它的意思是：在调试之前，先去执行编译任务。
            // 如果把这行删了，你修改代码后按 F5，运行的还是旧代码（因为没重新编译）。
            "preLaunchTask": "C/C++: g++.exe 生成活动文件"
        }
    ]
}</code></pre>

            <hr>

            <h2 id="sec-5">五、协作逻辑总结（厨房比喻）</h2>
            <p>为了帮你更好地理解这三个文件的关系，想象你在做菜：</p>
            <ol>
                <li><strong><code>c_cpp_properties.json</code> (菜谱校验)</strong>：
                    <ul>
                        <li>当你切菜（写代码）时，它在旁边告诉你：“哎，这个配方（语法）不对，找不到这个调料（头文件）”。</li>
                    </ul>
                </li>
                <li><strong><code>tasks.json</code> (厨师/烹饪)</strong>：
                    <ul>
                        <li>负责把食材（.cpp）扔进锅里（编译器），开火（运行 g++），做成成品菜（.exe）。</li>
                    </ul>
                </li>
                <li><strong><code>launch.json</code> (试吃员/调试)</strong>：
                    <ul>
                        <li>负责把做好的菜（.exe）端上来，并在你要求的地方停嘴（断点），让你检查味道（查看变量）。它会先喊厨师（<code>preLaunchTask</code>）先把菜做好。</li>
                    </ul>
                </li>
            </ol>

            <hr>

            <h2 id="sec-6">六、高级工作区定制 (settings.json)</h2>
            <p>你提到的“屏蔽搜索和文件显示”是在 <code>settings.json</code> 中配置的。这可以让你的项目目录看起来更干净，忽略掉编译产生的中间文件（如 <code>.o</code>, <code>.exe</code>）。</p>
            <p>在 <code>.vscode</code> 文件夹下新建或编辑 <code>settings.json</code>：</p>
            <pre><code class="language-json">{
    // 【文件资源管理器】排除规则：
    // files.exclude: 在左侧“资源管理器”中把文件藏起来
    "files.exclude": {
        "**/.git": true,        // 隐藏 .git 文件夹 (** 代表任意路径)
        "**/.svn": true,
        "**/.DS_Store": true,
        "**/*.o": true,         // 隐藏所有 .o 中间文件
        "**/*.obj": true,       // 隐藏所有 .obj 文件
        "**/*.exe": true,       // 隐藏所有 .exe 文件 (让目录看起来只有代码)
        "temp/": true           // 隐藏根目录下的 temp 文件夹
    },

    // 【全局搜索】排除规则：
    // search.exclude: 当你 Ctrl+Shift+F 搜索代码时，不搜索这些文件
    "search.exclude": {
        "**/node_modules": true,
        "**/bower_components": true,
        "**/*.code-search": true,
        "**/*.o": true,
        "**/*.exe": true,
        "**/build": true,       // 忽略 build 文件夹
        "**/dist": true         // 忽略 dist 文件夹
    },

    // 终端字体设置（可选）
    "terminal.integrated.fontFamily": "Consolas, 'Courier New', monospace"
}</code></pre>
            <p><strong>编写规则说明</strong>：</p>
            <ul>
                <li><strong>Glob 模式</strong>：
                    <ul>
                        <li><code>*</code> 匹配当前文件夹下的任意字符。</li>
                        <li><code>**</code> 匹配任意层级的路径。</li>
                    </ul>
                </li>
                <li><strong>布尔值</strong>：<code>true</code> 代表启用排除，<code>false</code> 表示禁用。</li>
            </ul>

            <hr>

            <h2 id="sec-7">七、如何调试代码</h2>
            <p>配置好上述 JSON 文件后：</p>
            <ol>
                <li>打开一个 <code>.cpp</code> 文件。</li>
                <li><strong>设置断点</strong>：在行号左侧点击，出现红点。</li>
                <li><strong>启动调试</strong>：按 <code>F5</code>。
                    <ul>
                        <li>VS Code 会先自动调用 <code>tasks.json</code> 编译代码。</li>
                        <li>编译成功后，调用 <code>launch.json</code> 启动调试。</li>
                    </ul>
                </li>
                <li><strong>调试面板操作</strong>：
                    <ul>
                        <li><strong>变量 (Variables)</strong>：查看当前局部变量的值。</li>
                        <li><strong>监视 (Watch)</strong>：手动添加想观察的变量或表达式（如 <code>i + 5</code>）。</li>
                        <li><strong>控制条</strong>：
                            <ul>
                                <li><code>F10</code> (单步跳过)：执行一行，遇到函数不进去。</li>
                                <li><code>F11</code> (单步调试)：执行一行，遇到函数会进去。</li>
                                <li><code>Shift+F5</code>：停止调试。</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>

            <hr>

            <h2 id="sec-8">八、如何打包发布软件 (Release)</h2>
            <p>C/C++ 和 Python/Java 不同，它编译出来就是机器码。但是，如果你直接把生成的 <code>.exe</code> 发给朋友，他可能打不开，提示“缺少 xxx.dll”。这是因为默认是<strong>动态链接</strong>。</p>

            <h3>1. 简单的静态链接打包 (适用于小工具)</h3>
            <p>我们要修改 <code>tasks.json</code>，让编译器把依赖库都打进 exe 里面。</p>
            <p>修改 <code>tasks.json</code> 中的 <code>args</code> 部分：</p>
            <pre><code class="language-json">"args": [
    "-fdiagnostics-color=always",
    "-O2",       // 【优化】开启 O2 优化 (发布版通常不需要 -g 调试信息，且需要优化速度)
    "${file}",
    "-o",
    "${fileDirname}\\${fileBasenameNoExtension}.exe",
    "-static"    // 【关键】静态链接，把库打入 exe，文件体积变大但不再依赖 dll
],</code></pre>
            <p><em>注意：修改后重新运行 Build 任务。生成的 <code>.exe</code> 就可以直接拷贝到别的电脑上运行了（前提是架构相同，如都是 x64 Windows）。</em></p>

            <h3>2. 多文件项目打包 (推荐 CMake)</h3>
            <p>对于超过一个 <code>.cpp</code> 文件的项目，手动写 <code>tasks.json</code> 会非常痛苦。建议使用 <strong>CMake</strong>。</p>
            <ol>
                <li>安装 <strong>CMake</strong> 工具并添加到 Path。</li>
                <li>在项目根目录创建 <code>CMakeLists.txt</code>：</li>
            </ol>
            <pre><code class="language-cmake">cmake_minimum_required(VERSION 3.0)
project(MyProject)

set(CMAKE_CXX_STANDARD 17)

# 添加可执行文件，包含所有源码
add_executable(MyApp src/main.cpp src/other.cpp)</code></pre>
            <ol start="3">
                <li>使用 VS Code 的 <strong>CMake Tools</strong> 插件，点击底部的 "Build" 按钮即可生成。</li>
            </ol>

            <hr>

            <h2>总结：文件结构速查</h2>
            <p>一个配置完善的 VS Code C++ 项目结构如下：</p>
            <pre><code class="language-text">MyProject/
├── .vscode/                 # VS Code 配置文件目录
│   ├── c_cpp_properties.json # IntelliSense 配置
│   ├── launch.json          # 调试运行配置
│   ├── tasks.json           # 编译构建命令配置
│   └── settings.json        # 屏蔽文件/搜索配置
├── src/                     # 源代码
│   ├── main.cpp
│   └── utils.cpp
├── include/                 # 头文件
│   └── utils.h
└── bin/                     # (可选) 输出目录，需在 task 中配置
    └── main.exe</code></pre>
            <p>通过这套配置，你不仅拥有了一个轻量级的 IDE，还掌握了底层构建的逻辑。这也就是 VS Code 的魅力所在。</p>

            <hr>
            
            <blockquote class="author-quote">
                <p>Author：李家琦</p>
                <p>Date: 2025/12/03</p>
            </blockquote>

        </article>
    </div>

    <!-- 音乐播放器挂载 -->
    <div class="music-player-widget">
        <div class="player-controls">
            <button id="prev-btn" title="Previous"><i class="fas fa-step-backward"></i></button>
            <button id="play-btn" title="Play/Pause"><i class="fas fa-play"></i></button>
            <button id="next-btn" title="Next"><i class="fas fa-step-forward"></i></button>
            <button id="mute-btn" title="Mute"><i class="fas fa-volume-up"></i></button>
        </div>
        <div class="song-info">
            <span id="song-title">Loading...</span>
        </div>
        <audio id="bg-music"></audio>
    </div>

    <!-- 定义根路径变量 (由于在 archive/c语言/ 下，所以是 ../../) -->
    <script>var ROOT_PATH = '../../';</script>
    
    <!-- 引入音乐脚本 -->
    <script src="../../static/js/music.js"></script>

	<script src="../../static/js/comment.js"></script>
	
    <!-- 引入 Prism.js 核心及语言包 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cmake.min.js"></script>
    
    <!-- 核心逻辑：处理返回链接 & 目录高亮 -->
    <script>
        // 1. 处理返回按钮逻辑
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const fromCat = urlParams.get('from'); 
            
            const backBtn = document.getElementById('back-btn');
            
            if (fromCat) {
                // 如果有 from 参数，就用它，处理 c/cpp 的转码
                backBtn.href = `../../archive/archive.html?cat=${encodeURIComponent(fromCat)}`;
                console.log("Back link set to:", backBtn.href);
            } else {
                // 默认回 C/C++ 分类
                backBtn.href = `../../archive/archive.html?cat=c/cpp`;
            }
        });

        // 2. 目录滚动监听
        const sections = document.querySelectorAll('h2');
        const navLinks = document.querySelectorAll('.toc-list a');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= (sectionTop - 200)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(a => {
                a.classList.remove('active');
                if (a.getAttribute('href').includes(current)) {
                    a.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
