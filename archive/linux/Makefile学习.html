<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Makefile构建指南 | 知识文档</title>
    <!-- 引入网站图标 -->
    <link rel="icon" type="image/svg+xml" href="../../static/images/favicon.svg">
    <!-- 引入字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;600&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- 引入图标 -->
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 代码高亮 Prism.js -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <!-- 引入全局样式 -->
    <link rel="stylesheet" href="../../static/css/style.css">

    <style>
        /* --- 文章专用局部样式 --- */
        body { padding-top: 80px; }

        /* 顶部导航条 */
        .article-header {
            background: rgba(11, 17, 32, 0.95);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 5%;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .back-btn {
            text-decoration: none;
            color: var(--primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: 0.3s;
            z-index: 20; /* 确保可点击 */
        }

        .back-btn:hover {
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
        }

        /* 布局容器 */
        .layout {
            display: flex;
            max-width: 1400px;
            margin: 40px auto;
            padding: 0 20px;
            gap: 40px;
        }

        /* 文章主体 */
        article {
            flex: 1;
            background: rgba(30, 41, 59, 0.6);
            padding: 40px;
            border-radius: 12px;
            border: 1px solid var(--border);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            max-width: 900px;
            overflow-x: hidden; /* 防止代码块撑破布局 */
        }

        /* 侧边目录 */
        aside {
            flex: 0 0 250px;
            position: sticky;
            top: 100px;
            height: fit-content;
            display: none;
        }

        @media (min-width: 1100px) { aside { display: block; } }

        /* 内容排版 */
        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 2rem;
            color: #fff;
            border-bottom: 1px solid var(--border);
            padding-bottom: 1rem;
            font-family: 'Orbitron', sans-serif;
        }

        h2 {
            font-size: 1.8rem;
            margin-top: 3rem;
            margin-bottom: 1rem;
            color: var(--primary);
            border-left: 5px solid var(--primary);
            padding-left: 15px;
            font-family: 'Orbitron', sans-serif;
        }

        h3 {
            font-size: 1.4rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
            color: #fff;
            font-family: 'Fira Code', monospace;
        }

        p, li {
            color: var(--text-main);
            margin-bottom: 1rem;
            font-family: 'Segoe UI', sans-serif;
            line-height: 1.8;
        }

        /* 代码与引用 */
        code {
            font-family: 'Fira Code', monospace;
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        pre {
            background: #0d1117 !important;
            border: 1px solid var(--border);
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        blockquote {
            border-left: 4px solid var(--accent);
            background: rgba(16, 185, 129, 0.05);
            padding: 1rem;
            margin: 1.5rem 0;
            color: #d1d5db;
            border-radius: 0 8px 8px 0;
        }

        /* 表格样式 */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            overflow: hidden;
        }
        th, td {
            padding: 12px 15px;
            border: 1px solid var(--border);
            text-align: left;
            color: var(--text-main);
        }
        th {
            background-color: rgba(14, 165, 233, 0.15);
            color: var(--primary);
            font-family: 'Fira Code', monospace;
            font-weight: bold;
        }

        /* 目录链接样式 */
        .toc-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
            padding-bottom: 5px;
        }
        .toc-list { list-style: none; padding: 0; }
        .toc-list li { margin-bottom: 10px; }
        .toc-list a {
            color: var(--text-muted);
            font-size: 0.9rem;
            transition: 0.2s;
            display: block;
            border-left: 2px solid transparent;
            padding-left: 10px;
            text-decoration: none;
        }
        .toc-list a:hover, .toc-list a.active {
            color: var(--accent);
            border-left-color: var(--accent);
        }
        
        /* 链接样式 */
        article a { color: var(--primary); text-decoration: none; border-bottom: 1px dashed var(--primary); }
        article a:hover { color: var(--accent); border-color: var(--accent); }
    </style>
</head>
<body>

    <!-- 动态背景容器 -->
    <div class="circuit-bg">
        <div class="line v-line" style="--delay: 0s; --left: 10%;"></div>
        <div class="line v-line" style="--delay: 5s; --left: 90%;"></div>
        <div class="line h-line" style="--delay: 2s; --top: 20%;"></div>
        <div class="line h-line" style="--delay: 7s; --top: 80%;"></div>
    </div>

    <!-- 顶部导航 -->
    <header class="article-header">
        <!-- 返回按钮：ID 用于 JS 动态修改链接 -->
        <a id="back-btn" href="../../archive/archive.html?cat=all" class="back-btn">
            <i class="fas fa-chevron-left"></i> <span>Back to Archive</span>
        </a>
        <div style="font-family: 'Fira Code'; color: var(--text-muted); font-size: 0.9rem;">
            system.read(mode=doc)
        </div>
    </header>

    <div class="layout">
        <!-- 侧边目录 (TOC) -->
        <aside>
            <div class="toc-title">DIRECTORY</div>
            <ul class="toc-list">
                <li><a href="#sec-1">01_什么是Makefile</a></li>
                <li><a href="#sec-2">02_编译过程&原理</a></li>
                <li><a href="#sec-3">03_基本格式与规则</a></li>
                <li><a href="#sec-4">04_Makefile变量</a></li>
                <li><a href="#sec-5">05_常用符号</a></li>
                <li><a href="#sec-6">06_常用函数</a></li>
                <li><a href="#sec-7">07_编译选项</a></li>
            </ul>
        </aside>

        <!-- 文章内容 -->
        <article>
            <h1>Makefile Learn</h1>

            <h2 id="sec-1">一、什么是Makefile</h2>
            <p>
                <a href="https://www.gnu.org/savannah-checkouts/gnu/make/manual/make.html" target="_blank">
                    <i class="fas fa-book"></i> makefile官方手册
                </a>
            </p>

            <h2 id="sec-2">二、编译过程&原理</h2>
            <blockquote>
                hello.c -> 预处理(cpp) -> hello.i -> 编译器(ccl) -> hello.s -> 汇编器(as) -> hello.o -> 链接器(ld) -> hello可执行二进制目标程序
            </blockquote>

            <table>
                <thead>
                    <tr>
                        <th>文件后缀</th>
                        <th>后缀含义</th>
                        <th>文件后缀</th>
                        <th>后缀含义</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>.a</td><td>静态库文件</td>
                        <td>.c</td><td>C语言源程序文件</td>
                    </tr>
                    <tr>
                        <td>.h</td><td>C语言头文件</td>
                        <td>.i</td><td>预处理文件</td>
                    </tr>
                    <tr>
                        <td>.o</td><td>目标文件可用于链接</td>
                        <td>.s</td><td>汇编文件</td>
                    </tr>
                    <tr>
                        <td>.so</td><td>动态(共享)库文件</td>
                        <td></td><td></td>
                    </tr>
                </tbody>
            </table>

            <h3>1. 预处理指令</h3>
            <pre><code class="language-bash">gcc -E [C源文件]           # 不输出任何预处理文件
gcc -E [C源文件] -o [输出的预处理文件]  # 输出指定名称的预处理文件</code></pre>

            <h3>2. 生成汇编语言指令</h3>
            <pre><code class="language-bash">gcc -S [C源文件]           # 不输出任何汇编文件
gcc -S [C源文件] -o [输出的汇编文件]  # 输出指定名称的汇编文件</code></pre>

            <h3>3. 生成目标文件指令</h3>
            <pre><code class="language-bash">gcc -c [C源文件]           # 不输出任何目标文件
gcc -c [C源文件] -o [输出的目标文件]  # 输出指定名称的目标文件</code></pre>

            <h3>4. 直接由源码生成可执行文件</h3>
            <pre><code class="language-bash">gcc [C源文件]              # 直接输出 "a.out"，使用 ./a.out可执行目标文件
gcc [C源文件] -o [输出的目标文件] # 指定输出的目标文件名称</code></pre>
            <p>//虽然没有写 -E -S -c 等命令，但不意味着上述过程没有执行</p>

            <h3>5. 生成静态库文件</h3>
            <ol>
                <li>编译成.o文件 <br> <code>gcc -c [.c] -o [自定义文件名]</code></li>
                <li>编译静态库 <br> <code>ar -r [lib自定义库名称.a] [.o] [.o]</code></li>
                <li>编译成可执行文件 <br> <code>gcc [.c] [.a] -o [自定义输出文件名]</code> <br> <code>gcc [.c] -o [自定义输出文件名] -l[库名] -L[库所在路径]</code></li>
                <li>链接静态库和C源文件生成可执行文件 <br> <code>gcc [C源文件] [静态库文件] -o [自定义输出文件名]</code></li>
            </ol>

            <h3>6. 生成动态库文件</h3>
            <ol>
                <li>编译输出.o文件 <br> <code>gcc -c -fpic [.c] [.c] ...</code></li>
                <li>编译动态库 <br> <code>gcc -shared [.o] [.o] ... -o [lib自定义库名.so]</code></li>
                <li>链接动态库和C源文件生成可执行文件 <br> <code>gcc [.c] -o [自定义可执行文件] -l[库名] -L[库路径] -Wl , -rpath=[库路径]</code></li>
            </ol>

            <h2 id="sec-3">三、Makefile基本格式、规则、伪目标</h2>
            <h3>1. 基本格式</h3>
            <pre><code class="language-makefile">targets(目标文件) : prerequisties(依赖项)
    command(shell命令)</code></pre>
            <p>targets可以是一个<code>[lable]</code>。命令前加一个 <strong>@</strong> 可以不打印命令。</p>

            <h3>2. Makefile规则</h3>
            <p>make会在当前目录下找到一个名为Makefile的文件。<br>
            找到后会查找第一个目标文件(targets)，并把这个文件作为最终的目标文件。<br>
            如果target文件不存在，或者是target文件依赖的.o文件(prerequities)的文件修改时间要比target这个文件新，就会执行后面所定义的命令command来生成target这个文件。<br>
            如果target以来的.o文件(prerequisties)也存在，make会在当前文件中找到target为.o文件的依赖项，如果找到，再根据那个规则生成.o文件。</p>

            <h3>3. 伪目标</h3>
            <p>"伪目标"不是一个文件，只是一个标签。我们要显示地指明这个"目标"才能让其生效。<br>
            "伪目标"的取名不能和文件名重名，否则不会执行命令。<br>
            为了避免和文件重名的这种情况。我们可以使用一个特殊标记， <strong>.PHONY</strong>来显示地指明一个目标是"伪目标"，向make说明，不管是否有这个文件，这个目标就是"伪目标"。</p>
            <pre><code class="language-makefile">.PHONY : clean</code></pre>

            <h2 id="sec-4">四、Makefile变量</h2>
            <h3>1. 变量的定义</h3>
            <pre><code class="language-makefile">c := src/main.c   #只是一个字符串
obj := objs/main.o</code></pre>

            <h3>2. 变量的引用</h3>
            <p>可以使用()或者{}</p>
            <pre><code class="language-makefile">$(obj) : ${cpp}       #目标文件$(obj) 依赖文件${cpp}</code></pre>

            <h3>3. 预定义变量</h3>
            <ul>
                <li><code>$@</code> : 目标(target)的完整名称，所有的目标文件</li>
                <li><code>$&lt;</code> : 第一个依赖文件(prerequisties)的名称</li>
                <li><code>$^</code> : 所有的依赖文件(prerequisties)，以空格分开，不包含重复的依赖文件</li>
            </ul>

            <h2 id="sec-5">五、Makefile常用符号</h2>
            <h3>1. =</h3>
            <ul>
                <li>简单的赋值运算符</li>
                <li>将右边的值分配给左边</li>
                <li>如果在后面的语句中重新定义了该变量，则使用新的值</li>
            </ul>
            <h3>2. :=</h3>
            <ul>
                <li>立即赋值运算符</li>
                <li>用于在定义变量时立即求值</li>
                <li>该值在定义后不再更改</li>
            </ul>
            <h3>3. ?=</h3>
            <ul>
                <li>默认赋值运算符</li>
                <li>如果该变量已经定义，则不进行任何操作</li>
                <li>如果该变量尚未定义，则求值并分配</li>
            </ul>
            <h3>4. +=</h3>
            <ul>
                <li>将右边的值加空格累加到左边的变量中</li>
            </ul>
            <h3>5. \</h3>
            <ul>
                <li>续行符，可以多行实际为一行</li>
            </ul>

            <h2 id="sec-6">六、Makefile的常用函数</h2>
            <p>函数调用，很像变量的使用，也是 <strong>"$"</strong> 来标识的，其语法如下：</p>
            <pre><code class="language-makefile">$(fn  arguments1 , argument2 , ...) or ${fn  arguments1 , argument2 , ...}
# fn:函数名
# arguments:函数参数，参数间以逗号，分隔 ， 而函数名和参数之间以空格分隔</code></pre>

            <h3>1. shell</h3>
            <pre><code class="language-makefile">$(shell &lt;command&gt; &lt;arguments&gt;)</code></pre>
            <ul>
                <li>名称：shell命令函数 ——shell</li>
                <li>功能：调用shell的命令</li>
                <li>返回：函数返回shell命令的执行结果</li>
            </ul>
            <p>例子：</p>
            <pre><code class="language-makefile">#shell 指令 ， 在src文件夹下找到全部的.cpp文件
cpp_src := $(shell find src -name *.cpp)</code></pre>

            <h3>2. subst</h3>
            <pre><code class="language-makefile">$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></pre>
            <ul>
                <li>名称：字符串替换函数——subst</li>
                <li>功能：把字符串&lt;text&gt;中的&lt;from&gt;字符串替换成&lt;to&gt;</li>
                <li>返回：函数返回被替换后的字符串</li>
            </ul>
            <pre><code class="language-makefile">name1 := test1
name2 := test2

$(subst test,${name1},{name2})
#将name2中的test替换为test1，最后输出的结果为test12</code></pre>

            <h3>3. patsubst</h3>
            <pre><code class="language-makefile">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></pre>
            <ul>
                <li>名称：模式字符串替换函数——patsubst</li>
                <li>功能：通配符%，表示任意长度的字符串，从text中取出pattern，替换成replacement</li>
                <li>返回：函数返回被替换后的字符串</li>
            </ul>
            <p>例子：</p>
            <pre><code class="language-makefile">name1 := test123

$(patsubst test,right,$(name1))
#将name1中的test替换为right并返回</code></pre>

            <h3>4. foreach</h3>
            <pre><code class="language-makefile">$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></pre>
            <ul>
                <li>名称：循环函数——foreach</li>
                <li>参数：&lt;var&gt;临时变量不会影响外部变量的值</li>
                <li>功能：把字串&lt;list&gt;中的元素逐一取出来，执行&lt;text&gt;包含的表达式</li>
                <li>返回: &lt;text&gt;所返回的每个字符串组成的整个字符串(以空格分隔)</li>
            </ul>
            <pre><code class="language-makefile">name1 := myname

name2 := $(foreach item,$(name1),-L$(item))
#将name1中的字符串取出加上-L</code></pre>

            <h3>5. dir</h3>
            <pre><code class="language-makefile">$(dir &lt;names...&gt;)</code></pre>
            <ul>
                <li>名称：取目录函数——dir</li>
                <li>功能：从文件名序列中取出目录部分。目录部分是指最有一个反斜杠("/")之前的部分。如果没有反斜杠，那么返回"./"</li>
                <li>返回：返回文件名序列的目录部分</li>
            </ul>
            <p>示例：</p>
            <pre><code class="language-makefile">$(dir src/foo.c hacks)
#返回值是"src/ ./"</code></pre>

            <h3>6. notdir</h3>
            <pre><code class="language-makefile">$(notdir &lt;names...&gt;)</code></pre>
            <ul>
                <li>功能：传入变量或列表，将其中的元素的路径去掉</li>
            </ul>

            <h3>7. filter</h3>
            <pre><code class="language-makefile">$(filter &lt;names...&gt;)</code></pre>
            <ul>
                <li>功能：根据参数过滤掉某些文件</li>
            </ul>

            <h3>8. basename</h3>
            <pre><code class="language-makefile">$(basename &lt;names...&gt;)</code></pre>
            <ul>
                <li>功能：去掉后缀</li>
            </ul>

            <p><strong>更多makefile函数参见</strong>:<a href="https://www.gnu.org/savannah-checkouts/gnu/make/manual/make.html#Foreach-Function" target="_blank">makefile函数</a></p>

            <h2 id="sec-7">七、Makefile编译</h2>
            <h3>1. Makefile编译步骤</h3>
            <p>1.1 预处理<br>
            1.2 编译成汇编语言<br>
            1.3 编译成.o文件<br>
            1.4 链接成可执行文件或库</p>

            <h3>2. 编译选项</h3>
            <blockquote>
                <p>编译选项</p>
            </blockquote>
            <ul>
                <li>-m64：指定编译为64位应用程序</li>
                <li>-std=：指定编译标准，例如：-std=c++11、-std=c++14</li>
                <li>-g：包含调试信息</li>
                <li>-w：不显示警告</li>
                <li>-O：优化等级，通常使用：-O3</li>
                <li>-I：加在头文件路径前</li>
                <li>-fpic：产生的没有绝对地址，全部使用相对地址，代码可以被加载到内存的任意位置，且可以正确的执行。</li>
            </ul>
            <blockquote>
                <p>链接选项</p>
            </blockquote>
            <ul>
                <li>-l：加在库名前面</li>
                <li>-L：加在库路径前面</li>
                <li>-Wl,&lt;选项&gt;：将逗号分隔的&lt;选项&gt;传递给链接器</li>
                <li>-rpath=："运行"的时候，去找的目录。运行的时候，要找.so文件，会从这个选项里指定的地方去找</li>
            </ul>

        </article>
    </div>

    <!-- 音乐播放器悬浮窗 -->
    <div class="music-player-widget">
        <div class="player-controls">
            <button id="prev-btn" title="Previous"><i class="fas fa-step-backward"></i></button>
            <button id="play-btn" title="Play/Pause"><i class="fas fa-play"></i></button>
            <button id="next-btn" title="Next"><i class="fas fa-step-forward"></i></button>
            <button id="mute-btn" title="Mute"><i class="fas fa-volume-up"></i></button>
        </div>
        <div class="song-info">
            <span id="song-title">Music Player Ready</span>
        </div>
        <!-- 隐藏的 Audio 标签 -->
        <audio id="bg-music"></audio>
    </div>

    <!-- 定义根路径变量 (二级子目录写 ../../) -->
    <script>const ROOT_PATH = '../../';</script>

    <!-- 引入 Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-makefile.min.js"></script>
    
    <!-- 引入音乐脚本 -->
    <script src="../../static/js/music.js"></script>

    <!-- 核心逻辑：处理返回链接 & 目录高亮 -->
    <script>
        // 1. 处理返回按钮逻辑
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const fromCat = urlParams.get('from'); 
            
            const backBtn = document.getElementById('back-btn');
            
            if (fromCat) {
                // 回到 archive.html 并带上筛选参数
                backBtn.href = `../../archive/archive.html?cat=${encodeURIComponent(fromCat)}`;
                console.log("检测到来源，返回链接已设定为:", backBtn.href);
            } else {
                // 默认返回全部
                backBtn.href = `../../archive/archive.html?cat=all`;
            }
        });

        // 2. 目录滚动监听
        const sections = document.querySelectorAll('h2');
        const navLinks = document.querySelectorAll('.toc-list a');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= (sectionTop - 200)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(a => {
                a.classList.remove('active');
                if (a.getAttribute('href').includes(current)) {
                    a.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
